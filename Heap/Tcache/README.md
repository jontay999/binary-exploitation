### Reference Links

- https://hackmd.io/@5Mo2wp7RQdCOYcqKeHl2mw/ByTHN47jf
- https://www.youtube.com/watch?v=Im1SqwOVsEQ
- https://play.picoctf.org/practice/challenge/146

### Notes

- TCACHE_MAX_BINS is 64
- the TCACHE struct can be observed with the `heap` command
- TCACHE count is the number of freed chunks so that they can be reused, otherwise the malloc operation is v slow
- each thread has their own tcache, to avoid race conditions
- tcache is initially memset out to 0, cannot just use to uninitialized memory which can tell you the false number of freed chunks if there are preexisting values
- heap likes to be aligned, so if you `malloc(0x80)` it might give you `0x90` bytes in order to give space for the chunk header or sth like that

- Source code

```c
 typedef struct tcache_perthread_struct
 {
   char counts[TCACHE_MAX_BINS];
   tcache_entry *entries[TCACHE_MAX_BINS];
 } tcache_perthread_struct;
```

- So over here, the first counts, has `0x0200000000000000` which means that the freed chunk that is at the particular index is 90 bytes. (idk why 90 yet)
- If there is more than 1 chunk with that same size we only see the address of the first chunk here which is `0x603890` but it is stored as a linked list, so the next freed chunk that of same size will be stored in the first chunk (if this value is lost --> lead to memory elaks)
  - in the first 8 bytes of the first freed chunk contains the pointer to the next freed chunks

```
pwndbg> x/32gx 0x602010
(tcache counts start here)
0x602010:       0x0200000000000000      0x0000000000000000
0x602020:       0x0000000000000000      0x0000000000000000
0x602030:       0x0000000000000000      0x0000000000000000
0x602040:       0x0000000000000000      0x0000000000000000
0x602050:       0x0000000000000000      0x0000000000000000
0x602060:       0x0000000000000000      0x0000000000000000
0x602070:       0x0000000000000000      0x0000000000000000
0x602080:       0x0000000000000000
(tcache starts here)                    0x0000000000603890
0x602090:       0x0000000000000000      0x0000000000000000
0x6020a0:       0x0000000000000000      0x0000000000000000
0x6020b0:       0x0000000000000000      0x0000000000000000
0x6020c0:       0x0000000000000000      0x0000000000000000
0x6020d0:       0x0000000000000000      0x0000000000000000
0x6020e0:       0x0000000000000000      0x0000000000000000
0x6020f0:       0x0000000000000000      0x0000000000000000
0x602100:       0x0000000000000000      0x0000000000000000
```

- For this particular challenge the relevant code is here

```c
flag_file = fopen("flag.txt","r");
fgets(flag_text,0x40,flag_file);
local_78 = L'\x73696874';
local_70 = 0x6d6f646e61722061;
local_68 = 0x2e676e6972747320;
local_60 = 0;
heap_address = (undefined8 *)0x0;
for (i = 0; i < 7; i = i + 1) {
chunk = (undefined8 *)malloc(0x80);
if (heap_address == (undefined8 *)0x0) {
    heap_address = chunk;
}
*chunk = L'\x676e6f43';
chunk[1] = L'\x6f592021';
chunk[2] = L'\x2067616c';
*(undefined *)(chunk + 3) = 0;
strcat((char *)chunk,flag_text);
}
error_msg = (undefined8 *)malloc(0x80);
*error_msg = L'\x72726f53';
error_msg[1] = 0x276e6f7720736968;
error_msg[2] = 0x7920706c65682074;
*(undefined4 *)(error_msg + 3) = 0x203a756f;
*(undefined *)((long)error_msg + 0x1c) = 0;
strcat((char *)error_msg,(char *)&local_78);
free(chunk);
free(error_msg);
input_address = 0;
input_value = 0;
puts("You may edit one byte in the program.");
printf("Address: ");
__isoc99_scanf("%d",&input_address);
printf("Value: ");
__isoc99_scanf(" %c",&input_value);
*(undefined *)((long)input_address + (long)heap_address) = input_value;
print_base = malloc(0x80);
puts((char *)((long)print_base + 0x10));
if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                /* WARNING: Subroutine does not return */
__stack_chk_fail();
}
return 0;
```

- Note that `strcat` copies our flag to the heap base

- The objective is to
  - find out what the heap_address is - initially pass in `0` as input_address (because it is an offset) in order to see the actual value of heap_address
    - from this picture, can see that the `add rdx,rax ` instruction corresponds to the adjusting the offset, so just examine the registers to see which address it is

![gdb](./gdb.png)

We want to supply the address of the tcache pointer to the initial freed chunks, and make it point to the place on the heap where our flag is stored. And so do some math where

`desired_address = heap_base - tcache_address`

Then for the byte to input, visualize the heap chunks and see which one to change it to in order to make malloc allocate there, and then the printf will print that flag at an offset 0x10

- Note: when sending null bytes, better to do `sendlineafter` otherwise might mess up
