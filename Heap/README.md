## General Notes

### Types of Memory

- `ELF .text`: where code lives
- `ELF .plt`: where library function stubs live (Procedural Linkage Table)
- `ELF .got`: where pointers to imported symbols live (Global Offset Table)
- `ELF .bss`: used for uninitialized global writable data, such as global arrays without initial starting values (block starting symbol)
- `ELF .data`: used for pre-initialized global writable data, e.g. global arrays with initial values
- `ELF .rodata`: used for global read-only data (such as string constants)
- `stack`: local variables, temporary storage, call stack metadata
- `Dynamic Memory`: --> heap!
  - Allow dynamic allocation/deallocation of memory according to changing program needs
  - Allocated memory survives across functions
  - Dynamic allocator basically `mmaps` out a page, and hands out chunks based on memory needs
    - Linux: `ptmalloc` - Posix Thread aware fork of `dlmalloc` (basically multithreaded)
    - FreeBSD: `jemalloc` (alos Firefox and Android)
    - Windows: Segment Heap, NT Heap
    - Kernel Allocators: `kmalloc` for Linux, and `kalloc` for iOS kernel
- `mmap`:

  - works on the basis of pages, so can only give multiples of 4006 bytes
  - is slow as requires kernel involvement

- What does the heap do (as provided by glibc/malloc)

  - `malloc()` - allocate some memory
  - `free()` - free a prior allocated chunk
  - `realloc()` - change size of allocation
  - `calloc()` - allocate and zero out memory

- data segment
  - with ASLR, is placed randomly into memory near to the PIE base
  - starts out with a size of 0
  - is managed by `brk` and `sbrk`
    - `sbrk(NULL)`: returns end of data segment
    - `sbrk(delta)`" expands end of data segment by delta bytes
    - `brk(addr)` expands the end of the data segment to addr

### References

- https://www.youtube.com/watch?v=coAJ4KyrWmY
